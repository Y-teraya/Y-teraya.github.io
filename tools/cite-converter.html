<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>参考文献コンバータ</title>
<style>
  body { monospace; margin: 1.5rem; }
  textarea { width: 100%; box-sizing: border-box; font-family: inherit; }
  #input { height: 250px; }
  #bibtexOutput, #refOutput, #logOutput { height: 220px; }
  .row { display: flex; gap: 1rem; margin-top: 1rem; }
  .col { flex: 1; display: flex; flex-direction: column; }
  label { font-weight: bold; }
  button { margin-right: 0.5rem; margin-top: 0.3rem; }
  select { margin-top: 0.3rem; }
  .small { font-size: 0.85rem; color: #555; }
  pre { white-space: pre-wrap; }
</style>
</head>
<body>

<h1>参考文献コンバータ</h1>

<div>
  <label for="fileInput">ファイル入力（.nbib / .ris / .bib / .txt）</label><br>
  <input id="fileInput" type="file" accept=".nbib,.ris,.bib,.txt">
  <button id="clearInputBtn">入力削除</button>
</div>

<div style="margin-top:0.5rem;">
  <label for="input">入力テキスト</label><br>
  <textarea id="input" placeholder="ここに nbib / RIS / BibTeX / テキストを貼り付け"></textarea>
</div>

<div class="row">
  <div class="col">
    <label for="bibtexOutput">BibTeX 出力</label>
    <textarea id="bibtexOutput" readonly></textarea>
    <div>
      <button id="convertBibtexBtn">BibTeX に変換</button>
      <button id="copyBibtexBtn">BibTeX をコピー</button>
    </div>
  </div>

  <div class="col">
    <label for="refOutput">参考文献リスト出力</label>
    <div id="refOutput" contenteditable="true" style="
        width:98%;
        height:220px;
        border:1px solid #ccc;
        padding:8px;
        overflow:auto;
        white-space:pre-wrap;
        font-family:inherit;">
    </div>
    <div>
      <label for="styleSelect">スタイル:</label>
      <select id="styleSelect">
        <option value="apa">APA</option>
        <option value="nogyokagaku">日本農芸化学会</option>
        <option value="shokubutsu">日本植物生理学会</option>
        <option value="dojofeiryo">日本土壌肥料学会</option>
        <option value="seibutsu">日本生物工学会</option>
        <option value="jozo">日本醸造学会</option>
      </select>
      <button id="convertRefBtn">参考文献リストに変換</button>
      <button id="copyRefBtn">参考文献リストをコピー</button>
    </div>
  </div>
</div>

<script>
// ========= ユーティリティ =========

// 文字列トリム（null セーフ）
function sTrim(s) {
  return (s || "").replace(/^\s+|\s+$/g, "");
}

// アクセント付き文字 → LaTeX アクセント
function convertAccentsToLatex(str) {
  if (!str) return "";
  const map = {
    "á": "\\'{a}", "Á": "\\'{A}",
    "é": "\\'{e}", "É": "\\'{E}",
    "í": "\\'{i}", "Í": "\\'{I}",
    "ó": "\\'{o}", "Ó": "\\'{O}",
    "ú": "\\'{u}", "Ú": "\\'{U}",
    "à": "\\`{a}", "À": "\\`{A}",
    "è": "\\`{e}", "È": "\\`{E}",
    "ì": "\\`{i}", "Ì": "\\`{I}",
    "ò": "\\`{o}", "Ò": "\\`{O}",
    "ù": "\\`{u}", "Ù": "\\`{U}",
    "ä": "\\\"{a}", "Ä": "\\\"{A}",
    "ë": "\\\"{e}", "Ë": "\\\"{E}",
    "ï": "\\\"{i}", "Ï": "\\\"{I}",
    "ö": "\\\"{o}", "Ö": "\\\"{O}",
    "ü": "\\\"{u}", "Ü": "\\\"{U}",
    "â": "\\^{a}", "Â": "\\^{A}",
    "ê": "\\^{e}", "Ê": "\\^{E}",
    "î": "\\^{i}", "Î": "\\^{I}",
    "ô": "\\^{o}", "Ô": "\\^{O}",
    "û": "\\^{u}", "Û": "\\^{U}",
    "ñ": "\\~{n}", "Ñ": "\\~{N}",
    "ç": "\\c{c}", "Ç": "\\c{C}",
    "ø": "\\o{}", "Ø": "\\O{}",
    "å": "\\aa{}", "Å": "\\AA{}"
  };
  return str.replace(/[^ -~]/g, function(ch) {
    return map[ch] || ch;
  });
}

// LaTeX アクセント → 元のアクセント文字に戻す
function decodeLatexAccents(str) {
  if (!str) return "";

  const map = {
    "\\'{a}": "á", "\\'{A}": "Á",
    "\\'{e}": "é", "\\'{E}": "É",
    "\\'{i}": "í", "\\'{I}": "Í",
    "\\'{o}": "ó", "\\'{O}": "Ó",
    "\\'{u}": "ú", "\\'{U}": "Ú",

    "\\`{a}": "à", "\\`{A}": "À",
    "\\`{e}": "è", "\\`{E}": "È",
    "\\`{i}": "ì", "\\`{I}": "Ì",
    "\\`{o}": "ò", "\\`{O}": "Ò",
    "\\`{u}": "ù", "\\`{U}": "Ù",

    "\\\"{a}": "ä", "\\\"{A}": "Ä",
    "\\\"{e}": "ë", "\\\"{E}": "Ë",
    "\\\"{i}": "ï", "\\\"{I}": "Ï",
    "\\\"{o}": "ö", "\\\"{O}": "Ö",
    "\\\"{u}": "ü", "\\\"{U}": "Ü",

    "\\^{a}": "â", "\\^{A}": "Â",
    "\\^{e}": "ê", "\\^{E}": "Ê",
    "\\^{i}": "î", "\\^{I}": "Î",
    "\\^{o}": "ô", "\\^{O}": "Ô",
    "\\^{u}": "û", "\\^{U}": "Û",

    "\\~{n}": "ñ", "\\~{N}": "Ñ",
    "\\c{c}": "ç", "\\c{C}": "Ç",

    "\\o{}": "ø", "\\O{}": "Ø",
    "\\aa{}": "å", "\\AA{}": "Å"
  };

  // まずアクセントを UTF-8 に戻す
  const keys = Object.keys(map).sort((a, b) => b.length - a.length);
  let out = str;
  for (const k of keys) {
    out = out.replace(new RegExp(k, "g"), map[k]);
  }

  // ★残ったバックスラッシュをすべて削除
  out = out.replace(/\\/g, "");

  return out;
}

// 月文字列 → 算用数字（先頭 0 なし）
function monthToNumber(mstr) {
  if (!mstr) return "";
  const lower = mstr.toLowerCase();
  const map = {
    jan: 1, january: 1,
    feb: 2, february: 2,
    mar: 3, march: 3,
    apr: 4, april: 4,
    may: 5,
    jun: 6, june: 6,
    jul: 7, july: 7,
    aug: 8, august: 8,
    sep: 9, sept: 9, september: 9,
    oct: 10, october: 10,
    nov: 11, november: 11,
    dec: 12, december: 12
  };
  return map[lower] ? String(map[lower]) : "";
}

// DP/DA など日付文字列 → {year, month}
function parseDateToYearMonth(datestr) {
  if (!datestr) return { year: "", month: "" };
  const s = datestr.trim();

  // 年-月-日, 年/月/日 など
  const ymddash = s.match(/^(\d{4})[-/](\d{1,2})[-/](\d{1,2})/);
  if (ymddash) {
    return { year: ymddash[1], month: String(parseInt(ymddash[2], 10)) };
  }

  // "2024 Jan 15" / "2024 Jan"
  const yMon = s.match(/^(\d{4})\s+([A-Za-z]+)/);
  if (yMon) {
    return { year: yMon[1], month: monthToNumber(yMon[2]) };
  }

  // "Jan 2024"
  const monY = s.match(/^([A-Za-z]+)\s+(\d{4})/);
  if (monY) {
    return { year: monY[2], month: monthToNumber(monY[1]) };
  }

  // "2024"
  const y = s.match(/^(\d{4})/);
  if (y) {
    return { year: y[1], month: "" };
  }

  return { year: "", month: "" };
}

// ページ 123–130, 123--130, 123 – 130 → 123-130
function normalizePages(pages) {
  if (!pages) return "";
  // 全角/ダッシュ類を普通の "-" に
  return pages.replace(/[–—−―‐–]+/g, "-").replace(/--+/g, "-");
}

// 著者文字列 → {last, first} の配列
// nbib/ris/bib からある程度共通で扱えるようにかなり素朴に実装
function parseAuthorString(authorStr) {
  if (!authorStr) return [];
  // 改行や " and " で分割
  const parts = authorStr
    .replace(/\r\n/g, "\n")
    .split(/\n| and /)
    .map(sTrim)
    .filter(a => a.length > 0);

  return parts.map(p => {
    // "Last, First Middle" 想定
    const m = p.split(",");
    if (m.length >= 2) {
      const last = sTrim(m[0]);
      const given = sTrim(m.slice(1).join(","));
      return { last, first: given };
    } else {
      // "First Last" 形式
      const toks = p.trim().split(/\s+/);
      if (toks.length === 1) {
        return { last: toks[0], first: "" };
      } else {
        return {
          last: toks[toks.length - 1],
          first: toks.slice(0, -1).join(" ")
        };
      }
    }
  });
}

// 著者配列 → BibTeX author 文字列（アクセント変換＋改行and）
function formatAuthorsForBibtex(authors) {
  if (!authors || authors.length === 0) return "";

  const parts = authors.map(a => {
    const last = convertAccentsToLatex(a.last || "");
    const first = convertAccentsToLatex(a.first || "");
    return first ? `${last}, ${first}` : last;
  });

  // RIS と同じ方式：join で一気に改行＋インデント
  return parts.join("\n      and ");
}

// 著者配列 → 引用用 "名前:年" の「名前」部分
// ここでは姓だけ（ある程度簡略）
function formatAuthorsForCitation(authors) {
  if (!authors || authors.length === 0) return "";
  if (authors.length === 1) return authors[0].last;
  if (authors.length === 2) return `${authors[0].last} & ${authors[1].last}`;
  return `${authors[0].last}`;
}

// ========= フォーマット判定 =========

function detectFormat(text) {
  const s = text.trim();
  if (!s) return "unknown";

  const firstLine = s.split(/\r?\n/)[0];
  if (/^PMID-/.test(firstLine)) return "nbib";
  if (/^TY\s+-/.test(firstLine)) return "ris";
  if (/^@/.test(firstLine)) return "bibtex";
  return "txt";
}

// ========= nbib パーサ =========

function parseNbib(text) {
  const lines = text.replace(/\r\n/g, "\n").split("\n");
  const entries = [];
  let current = null;

  function pushCurrent() {
    if (current) entries.push(current);
    current = {
      type: "article",
      raw: {},
      authors: [], // {last, first}
      title: "",
      journal: "",
      volume: "",
      number: "",
      pages: "",
      year: "",
      month: "",
      issn: "",
      doi: "",
      url: "",
      eprint: "",
      publisher: "",
      address: "",
      note: "",
      pmid: "",
      pmcid: ""
    };
  }

  for (let line of lines) {
    if (!line.trim()) {
      continue;
    }
    const m = line.match(/^([A-Z0-9]{2,4})\s*-\s*(.*)$/);
    if (!m) {
      // continuation line
      if (current && current._lastTag) {
        current.raw[current._lastTag] =
          (current.raw[current._lastTag] || "") + " " + line.trim();
      }
      continue;
    }
    const tag = m[1];
    const val = m[2].trim();

    if (tag === "PMID") {
      // レコード開始
      if (current) pushCurrent();
      pushCurrent();
      current.pmid = val;
    }
    current._lastTag = tag;
    current.raw[tag] = (current.raw[tag] || "");
    if (current.raw[tag]) current.raw[tag] += " ";
    current.raw[tag] += val;
  }
  if (current) entries.push(current);

  // nbib → 共通フィールドへマッピング
  for (const e of entries) {
    const r = e.raw;

// 著者: FAU のみ使用
const auList = [];

if (r["FAU"]) {
  // FAU は複数行のはずなので、テキストから FAU 行を抽出
  const lines = text.match(/^FAU\s*-\s*(.*)$/gm) || [];
  for (const l of lines) {
    const v = l.split("-")[1].trim();
    auList.push(v);
  }
}
    // "Last, First M" と仮定
    e.authors = auList.map(a => {
      const parts = a.split(",");
      if (parts.length >= 2) {
        return { last: sTrim(parts[0]), first: sTrim(parts.slice(1).join(",")) };
      } else {
        const toks = a.trim().split(/\s+/);
        return {
          last: toks[toks.length - 1],
          first: toks.slice(0, -1).join(" ")
        };
      }
    });

    // タイトル: TI
    e.title = r["TI"] || "";

    // 雑誌名: JT(正式) / TA(略称)
    e.journal = r["JT"] || r["TA"] || "";

    // volume / issue
    e.volume = r["VI"] || "";
    e.number = r["IP"] || "";

    // pages
    e.pages = normalizePages(r["PG"] || "");

    // DOI (LID に "doi " などが含まれうる)
    if (r["LID"]) {
      const mdoi = r["LID"].match(/10\.\S+/);
      if (mdoi) e.doi = mdoi[0].replace(/[.;]$/, "");
    }

    // PMID / PMCID
    e.pmid = r["PMID"] || e.pmid;
    if (r["PMC"]) e.pmcid = r["PMC"];

    // URL (ない場合が多いので空)
    e.url = "";

    // DP から year / month
    const dp = r["DP"] || "";
    const dObj = parseDateToYearMonth(dp);
    e.year = dObj.year;
    e.month = dObj.month;

    // note に PMID / PMCID
    const notes = [];
    if (e.pmid) notes.push(`PMID: ${e.pmid}`);
    if (e.pmcid) notes.push(`PMCID: ${e.pmcid}`);
    e.note = notes.join("; ");
  }

  return entries;
}

// ========= RIS パーサ =========

function parseRis(text) {
  const lines = text.replace(/\r\n/g, "\n").split("\n");
  const entries = [];
  let current = null;

  function pushCurrent() {
    if (current) entries.push(current);
    current = {
      type: "article",
      raw: {},
      authors: [],
      title: "",
      journal: "",
      volume: "",
      number: "",
      pages: "",
      year: "",
      month: "",
      issn: "",
      doi: "",
      url: "",
      eprint: "",
      publisher: "",
      address: "",
      note: ""
    };
  }

  for (let line of lines) {
    const m = line.match(/^([A-Z0-9]{2})\s*-\s*(.*)$/);
    if (!m) continue;
    const tag = m[1];
    const val = m[2].trim();

    if (tag === "TY") {
      pushCurrent();
      current.raw["TY"] = val;
      current._lastTag = tag;
      continue;
    }
    if (!current) continue;

    if (tag === "ER") {
      // entry end
      continue;
    }
    current.raw[tag] = current.raw[tag] || [];
    current.raw[tag].push(val);
    current._lastTag = tag;
  }
  if (current) entries.push(current);

  // マッピング
  for (const e of entries) {
    const r = e.raw;

    // 参照タイプ
    const ty = (r["TY"] || [""])[0].toUpperCase();
    if (ty === "JOUR") e.type = "article";
    else if (ty === "BOOK") e.type = "book";
    else e.type = "article";

    // 著者: AU
    const au = r["AU"] || [];
    e.authors = au.map(a => {
      const parts = a.split(",");
      if (parts.length >= 2) {
        return { last: sTrim(parts[0]), first: sTrim(parts.slice(1).join(",")) };
      } else {
        const toks = a.trim().split(/\s+/);
        return {
          last: toks[toks.length - 1],
          first: toks.slice(0, -1).join(" ")
        };
      }
    });

    // タイトル: TI / T1
    e.title = (r["TI"] && r["TI"][0]) ||
              (r["T1"] && r["T1"][0]) || "";

    // ジャーナル名: T2 / JO
    e.journal = (r["T2"] && r["T2"][0]) ||
                (r["JO"] && r["JO"][0]) || "";

    // volume / issue
    e.volume = (r["VL"] && r["VL"][0]) || "";
    e.number = (r["IS"] && r["IS"][0]) || "";

    // pages: SP / EP
    const sp = (r["SP"] && r["SP"][0]) || "";
    const ep = (r["EP"] && r["EP"][0]) || "";
    let pages = "";
    if (sp && ep) pages = `${sp}-${ep}`;
    else if (sp) pages = sp;
    e.pages = normalizePages(pages);

    // DOI
    e.doi = (r["DO"] && r["DO"][0]) || "";

    // URL
    e.url = (r["UR"] && r["UR"][0]) || "";

    // publisher, address
    e.publisher = (r["PB"] && r["PB"][0]) || "";
    e.address = (r["CY"] && r["CY"][0]) || "";

    // 日付: DA(なければY1)
    const da = (r["DA"] && r["DA"][0]) || (r["Y1"] && r["Y1"][0]) || "";
    const dObj = parseDateToYearMonth(da);
    e.year = dObj.year;
    e.month = dObj.month;
  }

  return entries;
}

// ========= BibTeX パーサ（最低限） =========

function parseBibtex(text) {
  const entries = [];
  const re = /@(\w+)\s*\{\s*([^,]+),([\s\S]*?)}\s*(?=@|$)/g;
  let m;
  while ((m = re.exec(text)) != null) {
    const type = m[1].toLowerCase();
    const key = m[2].trim();
    const body = m[3];

    const fields = {};
    const fRe = /(\w+)\s*=\s*({([^{}]*|{[^{}]*})*}|\"[^\"]*\"|[^,\n]+)\s*,?/g;
    let fm;
    while ((fm = fRe.exec(body)) != null) {
      const fname = fm[1].toLowerCase();
      let fval = fm[2].trim();
      if ((fval[0] === "{" && fval[fval.length-1] === "}") ||
          (fval[0] === "\"" && fval[fval.length-1] === "\"")) {
        fval = fval.substring(1, fval.length-1);
      }
      if (fname === "month") {
        const monthNum = monthToNumber(fval);
        fields[fname] = monthNum || fval;
      } else {
        fields[fname] = fval;
  }

    }

    // 共通構造に詰め替え
    const authors = parseAuthorString(fields["author"] || "");
    const dObj = parseDateToYearMonth(fields["year"] || "");

    entries.push({
      type: type,
      key: key,
      authors: authors,
      title: fields["title"] || "",
      journal: fields["journal"] || "",
      volume: fields["volume"] || "",
      number: fields["number"] || "",
      pages: normalizePages(fields["pages"] || ""),
      year: dObj.year || fields["year"] || "",
      month: fields["month"] || "",
      issn: normalizeISSN(fields["issn"] || ""),
      doi: fields["doi"] || "",
      url: fields["url"] || "",
      eprint: fields["eprint"] || "",
      publisher: fields["publisher"] || "",
      address: fields["address"] || "",
      note: fields["note"] || ""
    });
  }
  return entries;
}

// ========= 共通 → BibTeX 変換 =========

function toBibtex(entries) {
  const lines = [];
  lines.push("@comment{}");

  entries.forEach((e, idx) => {

    // --- 安全な author 処理 ---
    const safeAuthors = Array.isArray(e.authors) ? e.authors : [];

    const keyBase =
      (safeAuthors.length > 0
        ? formatAuthorsForCitation(safeAuthors)
        : `ref${idx+1}`);

    const keyYear = e.year || "xxxx";
    const key = (keyBase.replace(/\s+/g, "") + keyYear).toLowerCase();

    const authorStr =
      (safeAuthors.length > 0
        ? formatAuthorsForBibtex(safeAuthors)
        : "");

    // --- ISSN は削除済み ---
    const fields = [
      ["author", authorStr],
      ["title", convertAccentsToLatex(e.title)],
      ["publisher", convertAccentsToLatex(e.publisher)],
      ["journal", convertAccentsToLatex(e.journal)],
      ["volume", e.volume],
      ["number", e.number],
      ["pages", e.pages],
      ["year", e.year],
      ["month", e.month],
      ["doi", e.doi],
      ["url", e.url],
      ["eprint", e.eprint]
    ];

    let body = "";
    fields.forEach(([name, value], i) => {
      const safeVal = value || "";
      body += `  ${name} = {${safeVal}}`;
      if (i < fields.length - 1) body += ",\n";
    });

    lines.push(`\n@${e.type || "article"}{${key},\n${body}\n}`);
  });

  return lines.join("\n");
}

// ========= 共通 → 参考文献リスト（各スタイル） =========

// HTMLタグを一応通す（貼り付け先が対応していれば斜体・太字維持）
function escHtml(s) {
  return (s || "").replace(/[&<>]/g, c => {
    return { "&": "&amp;", "<": "&lt;", ">": "&gt;" }[c] || c;
  });
}

function formatAuthorsForStyle_all(authors, limit, etAlText) {
  // limit までフル、超えたら et al. or ら など
  if (!authors || authors.length === 0) return "";

  if (!limit || authors.length <= limit) {
    return authors.map(a => `${a.last} ${a.first}`.trim()).join(", ");
  }
  const head = authors.slice(0, limit).map(a => `${a.last} ${a.first}`.trim()).join(", ");
  return `${head}, ${etAlText}`;
}

// -- 個別スタイル（ざっくり。細かいところは必要に応じて調整用） --

function formatRefNogyokagaku(e, index) {
  // 日本農芸化学会
  // 著者全員: 姓, 名イニシャル。10人超なら5人+et al.
  let authors = e.authors.map(a => {
    const initials = (a.first || "")
      .split(/\s+/)
      .filter(x => x)
      .map(x => x[0] + ".")
      .join("");
    return `${a.last} ${initials}`;
  });
  if (authors.length > 10) {
    authors = authors.slice(0, 5);
    authors.push("et al.");
  }
  const authorsStr = authors.join(", ");

  const yearStr = e.year ? `(${e.year}).` : "";
  const title = e.title ? `${e.title}.` : "";
  const journal = e.journal ? `<i>${escHtml(e.journal)}</i>` : "";
  const vol = e.volume ? ` <b>${escHtml(e.volume)}</b>` : "";
  const pages = e.pages ? `, ${escHtml(e.pages)}` : "";
  const yearBlock = e.year ? ` (${escHtml(e.year)}).` : "";

  return `${index}). ${escHtml(authorsStr)}, ${title} ${journal},${vol}${pages}${yearBlock}`;
}

function formatRefSeibutsu(e, index) {
  // 日本生物工学会（かなり単純化）
  const authors = e.authors.map(a => `${a.last}, ${a.first}`).join(", ");
  const journal = e.journal ? `<i>${escHtml(e.journal)}</i>` : "";
  const vol = e.volume ? `, <b>${escHtml(e.volume)}</b>` : "";
  const pages = e.pages ? `, ${escHtml(e.pages)}` : "";
  const year = e.year ? ` (${escHtml(e.year)})` : "";
  return `${index}) ${escHtml(authors)}: ${journal}${vol}${pages}${year}.`;
}

function formatRefJozo(e, index) {
  // 日本醸造学会（雑誌名イタリック、巻ボールド）
  const authors = e.authors.map(a => `${a.last}, ${a.first}`).join(", ");
  const journal = e.journal ? `<i>${escHtml(e.journal)}</i>` : "";
  const vol = e.volume ? `, <b>${escHtml(e.volume)}</b>` : "";
  const pages = e.pages ? `, ${escHtml(e.pages)}` : "";
  const year = e.year ? ` (${escHtml(e.year)})` : "";
  return `${index}) ${escHtml(authors)}: ${journal}${vol}${pages}${year}.`;
}

function formatRefShokubutsu(e) {
  // 日本植物生理学会：著者6名超で et al.
  let authors = e.authors.map(a => `${a.last}, ${a.first}`).join(", ");
  if (e.authors.length > 6) {
    const first6 = e.authors.slice(0, 6).map(a => `${a.last}, ${a.first}`).join(", ");
    authors = `${first6} et al.`;
  }
  const year = e.year ? ` (${escHtml(e.year)})` : "";
  const title = e.title ? ` ${escHtml(e.title)}.` : "";
  const journal = e.journal ? ` <i>${escHtml(e.journal)}</i>` : "";
  const vol = e.volume ? ` <b>${escHtml(e.volume)}</b>` : "";
  const pages = e.pages ? `: ${escHtml(e.pages)}` : "";
  return `${escHtml(authors)}${year}${title}${journal}${vol}${pages}.`;
}

function formatRefDojo(e) {
  // 日本土壌肥料学会 風（かなり単純化）
  // 日本語著者が混ざるときもあるので、名字だけ / イニシャルはここでは凝らない
  const authors = e.authors.map(a => `${a.last} ${a.first}`.trim()).join("・");
  const year = e.year ? ` ${escHtml(e.year)}.` : "";
  const title = e.title ? ` ${escHtml(e.title)}.` : "";
  const journal = e.journal ? ` <i>${escHtml(e.journal)}</i>` : "";
  const vol = e.volume ? `, <b>${escHtml(e.volume)}</b>` : "";
  const pages = e.pages ? `, ${escHtml(e.pages)}` : "";
  return `${escHtml(authors)}${year}${title}${journal}${vol}${pages}.`;
}

function formatRefAPA(e) {
  // ざっくり APA 風
  const authors = e.authors.map((a, i) => {
    const initials = (a.first || "")
      .split(/\s+/)
      .filter(x => x)
      .map(x => x[0].toUpperCase() + ".")
      .join(" ");
    return `${a.last}, ${initials}`;
  }).join(", ");

  const year = e.year ? ` (${escHtml(e.year)}).` : " (n.d.).";
  const title = e.title ? ` ${escHtml(e.title)}.` : "";
  const journal = e.journal ? ` <i>${escHtml(e.journal)}</i>` : "";
  const vol = e.volume ? `, <i>${escHtml(e.volume)}</i>` : "";
  const num = e.number ? `(${escHtml(e.number)})` : "";
  const pages = e.pages ? `, ${escHtml(e.pages)}` : "";
  const doi = e.doi ? ` https://doi.org/${escHtml(e.doi)}` : "";
  return `${escHtml(authors)}${year}${title}${journal}${vol}${num}${pages}.${doi}`;
}

function toReferenceList(entries, style) {

  // ★ここでまとめてアクセントを UTF-8 に戻す
  entries = entries.map(e => {
    return {
      ...e,
      title: decodeLatexAccents(e.title),
      journal: decodeLatexAccents(e.journal),
      publisher: decodeLatexAccents(e.publisher),
      authors: e.authors.map(a => ({
        last: decodeLatexAccents(a.last),
        first: decodeLatexAccents(a.first)
      }))
    };
  });

  let out = [];
  entries.forEach((e, i) => {
    let line = "";
    switch (style) {
      case "nogyokagaku":
        line = formatRefNogyokagaku(e, i + 1);
        break;
      case "seibutsu":
        line = formatRefSeibutsu(e, i + 1);
        break;
      case "jozo":
        line = formatRefJozo(e, i + 1);
        break;
      case "shokubutsu":
        line = formatRefShokubutsu(e);
        break;
      case "dojofeiryo":
        line = formatRefDojo(e);
        break;
      case "apa":
      default:
        line = formatRefAPA(e);
        break;
    }
    out.push(line);
  });
  // スタイル定義では「1行空け」もあるが、ここでは1エントリ1行にしておく
  return out.join("\n");
}

// ========= イベントハンドラ =========

const inputEl = document.getElementById("input");
const bibtexOutputEl = document.getElementById("bibtexOutput");
const refOutputEl = document.getElementById("refOutput");
const logOutputEl = document.getElementById("logOutput");

document.getElementById("fileInput").addEventListener("change", function(e) {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = function(ev) {
    inputEl.value = ev.target.result;
  };
  reader.readAsText(file, "UTF-8");
});

document.getElementById("clearInputBtn").addEventListener("click", function() {
  inputEl.value = "";
  logOutputEl.value = "";
});

document.getElementById("convertBibtexBtn").addEventListener("click", function() {
  const text = inputEl.value;
  const fmt = detectFormat(text);
  let entries = [];
  let log = `検出フォーマット: ${fmt}\n`;

  if (fmt === "nbib") {
    entries = parseNbib(text);
    log += `nbib エントリ数: ${entries.length}\n`;
  } else if (fmt === "ris") {
    entries = parseRis(text);
    log += `RIS エントリ数: ${entries.length}\n`;
  } else if (fmt === "bibtex") {
    entries = parseBibtex(text);
    log += `BibTeX エントリ数: ${entries.length}\n`;
  } else {
    log += "txt/unknown: 自動変換対象外（手動編集してください）\n";
  }

  if (entries.length === 0) {
    bibtexOutputEl.value = "";
    logOutputEl.value = log + "変換対象エントリがありません。";
    return;
  }

  const bib = toBibtex(entries);
  bibtexOutputEl.value = bib;
  logOutputEl.value = log + "BibTeX 変換完了。";
});

document.getElementById("convertRefBtn").addEventListener("click", function() {
  const text = inputEl.value;
  const fmt = detectFormat(text);
  const style = document.getElementById("styleSelect").value;
  let entries = [];
  let log = `検出フォーマット: ${fmt}\n`;

  if (fmt === "nbib") {
    entries = parseNbib(text);
    log += `nbib エントリ数: ${entries.length}\n`;
  } else if (fmt === "ris") {
    entries = parseRis(text);
    log += `RIS エントリ数: ${entries.length}\n`;
  } else if (fmt === "bibtex") {
    entries = parseBibtex(text);
    log += `BibTeX エントリ数: ${entries.length}\n`;
  } else {
    log += "txt/unknown: 自動変換対象外（手動編集してください）\n";
  }

  if (entries.length === 0) {
    refOutputEl.value = "";
    logOutputEl.value = log + "変換対象エントリがありません。";
    return;
  }

  const ref = toReferenceList(entries, style);
  refOutputEl.innerHTML = ref;
  logOutputEl.value = log + `参考文献スタイル(${style}) 変換完了。`;
});

// --- ① 関数を外に定義 ---
function copyRef() {
  const range = document.createRange();
  range.selectNodeContents(refOutputEl);
  const sel = window.getSelection();
  sel.removeAllRanges();
  sel.addRange(range);
  document.execCommand("copy");
  sel.removeAllRanges();
}

// --- ② BibTeX コピー ---
document.getElementById("copyBibtexBtn").addEventListener("click", function() {
  bibtexOutputEl.select();
  document.execCommand("copy");
});

// --- ③ 参考文献コピー（1 回だけ登録） ---
document.getElementById("copyRefBtn").addEventListener("click", copyRef);
</script>
</body>

<footer>
  Copyright © 2025 by Y-teraya is marked 
  <a href="https://creativecommons.org/publicdomain/zero/1.0">CC0 1.0 Universal</a><br>
  [最終更新日：2026年1月13日]
</footer>

</html>